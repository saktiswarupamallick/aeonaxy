{"version":3,"names":["path","require","ACTIONS","exports","GET_VERSION","GET_TYPES_INFO","GET_VISITOR_KEYS","GET_TOKEN_LABELS","MAYBE_PARSE","MAYBE_PARSE_SYNC","_send","WeakMap","_vCache","_tiCache","_vkCache","_tlCache","Client","constructor","send","_classPrivateFieldInitSpec","_classPrivateFieldSet","getVersion","_classPrivateFieldGet2","_classPrivateFieldGet","call","undefined","getTypesInfo","_classPrivateFieldGet3","getVisitorKeys","_classPrivateFieldGet4","getTokLabels","_classPrivateFieldGet5","maybeParse","code","options","_worker","WorkerClient","action","payload","signal","Int32Array","SharedArrayBuffer","subChannel","_get_worker_threads","MessageChannel","postMessage","port","port1","Atomics","wait","message","receiveMessageOnPort","port2","error","Object","assign","errorData","result","Worker","resolve","__dirname","env","SHARE_ENV","unref","_this","_worker_threads_cache2","_worker_threads_cache","_","_LocalClient","_handleMessage","LocalClient","_assertClassBrand$_","_assertClassBrand"],"sources":["../src/client.cts"],"sourcesContent":["import type { Options } from \"./types.cts\";\n\nimport path = require(\"path\");\n\nexport const enum ACTIONS {\n  GET_VERSION = \"GET_VERSION\",\n  GET_TYPES_INFO = \"GET_TYPES_INFO\",\n  GET_VISITOR_KEYS = \"GET_VISITOR_KEYS\",\n  GET_TOKEN_LABELS = \"GET_TOKEN_LABELS\",\n  MAYBE_PARSE = \"MAYBE_PARSE\",\n  MAYBE_PARSE_SYNC = \"MAYBE_PARSE_SYNC\",\n}\n\nexport class Client {\n  #send;\n\n  constructor(send: Function) {\n    this.#send = send;\n  }\n\n  #vCache: string;\n  getVersion() {\n    return (this.#vCache ??= this.#send(ACTIONS.GET_VERSION, undefined));\n  }\n\n  #tiCache: any;\n  getTypesInfo() {\n    return (this.#tiCache ??= this.#send(ACTIONS.GET_TYPES_INFO, undefined));\n  }\n\n  #vkCache: any;\n  getVisitorKeys() {\n    return (this.#vkCache ??= this.#send(ACTIONS.GET_VISITOR_KEYS, undefined));\n  }\n\n  #tlCache: any;\n  getTokLabels() {\n    return (this.#tlCache ??= this.#send(ACTIONS.GET_TOKEN_LABELS, undefined));\n  }\n\n  maybeParse(code: string, options: Options) {\n    return this.#send(ACTIONS.MAYBE_PARSE, { code, options });\n  }\n}\n\n// We need to run Babel in a worker for two reasons:\n// 1. ESLint workers must be CJS files, and this is a problem\n//    since Babel 8+ uses native ESM\n// 2. ESLint parsers must run synchronously, but many steps\n//    of Babel's config loading (which is done for each file)\n//    can be asynchronous\n// If ESLint starts supporting async parsers, we can move\n// everything back to the main thread.\nexport class WorkerClient extends Client {\n  static #worker_threads_cache: typeof import(\"worker_threads\");\n  static get #worker_threads() {\n    return (WorkerClient.#worker_threads_cache ??= require(\"worker_threads\"));\n  }\n\n  #worker = new WorkerClient.#worker_threads.Worker(\n    path.resolve(__dirname, \"../lib/worker/index.cjs\"),\n    { env: WorkerClient.#worker_threads.SHARE_ENV },\n  );\n\n  constructor(